## 1、线性表基础

#### 1.1	什么是线性表

​	线性表是由相同数据类型的n个数据元素a0，a1 ... an组成的有限序列。

#### 1.2	什么是顺序表

​	顺序表是线性表的一种顺序存储方式。也就是说，线性表是逻辑结构，表示元素一对一的相邻关系；而顺序表是存储结构，是指用一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置也也相邻。

##### 1.2.1	顺序表的基本性质

​	顺序表在程序中通常用一维数组来实现，一维数组可以是动态分配，也可以是静态分配。在静态分配时，由于数组大小空间是固定的，一旦空间占满就无法新增数据，否则会导致溢出；而在动态分配时，存储空间会在程序执行过程动态调整大小，当空间占满时，可以另行开辟更大的存储空间来存储数据。

​	顺序表最主要的特点是支持随机访问，在O(1)的时间复杂度内找到指定元素；不足之处是插入和删除操作时需要移动大量元素，从而保持逻辑上和物理上的连续性。

##### 1.2.5	顺序表的基本操作

​	顺序表的构造，插入，扩容

```c
#include <iostream>
#include <cstring>
using std::cin;
using std::cout;
using std::endl;
template <typename Type> class Vector {
private:
    int size;
    int length;
    Type *data;
public:
    Vector(int input_size) {
        size = input_size;
        length = 0;
        data = new Type[size];
    }
    ~Vector() {
        delete [] data;
    }
    bool insert(int loc, int value) {
        if(loc < 0 || loc > length)
        {
            return false;
        }
        if(length >= size)
        {
            expand();
        }
        for(int i = length; i > loc; i--)
        {
            data[i] = data[i-1];
        }
        data[loc] = value;
        length++;
        return true;
    }
    void expand() {
        Type *old_data;
        old_data = data;
        size = size * 2;
        data = new Type[size];
        for(int i = 0; i < length; i++)
        {
            data[i] = old_data[i];
        }
        cout << "expand" << endl;
        delete [] old_data;
    }
};
int main() {
    Vector<int> a(5);
    int n, loc, value;
    bool flag;
    cin >> n;
    while(n)
    {
        cin >> loc >> value;
        flag = a.insert(loc, value);
        if(flag)
        {
            cout << "success" << endl;
        }
        else
        {
            cout << "failed" << endl;
        }
        n--;
    }
    return 0;
}
```



顺序表的查找，遍历，删除

```c
#include <iostream>
#include <cstring>
using std::cin;
using std::cout;
using std::endl;
template <typename Type> class Vector {
private:
    int size;
    int length;
    Type * data;
public:
    Vector(int input_size) {
        size = input_size;
        length = 0;
        data = new Type[size];
    }
    ~Vector() {
        delete [] data;
    }
    bool insert(int loc, int val) {
        if(loc < 0 || loc > length)
        {
            cout << "failed" << endl;
            return false;
        }
        if(length >= size)
        {
            expand();
        }
        for(int i = length; i > loc; i--)
        {
            data[i] = data[i-1];
        }
        data[loc] = val;
        length++;
        cout << "success" << endl;
        return true;
    }
    void expand() {
        Type *old_data;
        old_data = data;
        size *= 2;
        data = new Type[size];
        for(int i = 0; i < length; i++)
        {
            data[i] = old_data[i];
        }
        delete [] old_data;
    }
    bool search(int ele) {
        for(int i = 0; i < length; i++)
        {
            if(data[i] == ele)
            {
                cout << "success" << endl;
                return true;
            }
        }
        cout << "failed" << endl;
        return true;
    }
    bool remove(int index) {
        if(index < 0 || index >= length)
        {
            cout << "failed" << endl;
            return false;
        }
        for(int i = index + 1; i < length; i++)
        {
            data[i-1] = data[i];
        }
        length--;
        cout << "success" << endl;
        return true;
    }
    void print() {
        for(int i = 0; i < length; i++)
        {
            cout << data[i];
            if(i != length-1)
                cout << " ";
        }
        cout << endl;
    }
};
int main() {
    Vector<int> v(20);
    int m, t;
    cin >> m;
    //int count = 0;
    while(m)
    {
        cin >> t;
        if(t == 1)
        {
            int a, b;
            cin >> a >> b;
            v.insert(a, b);
        }
        if(t == 2)
        {
            int a;
            cin >> a;
            v.remove(a);
        }
        if(t == 3)
        {
            int a;
            cin >> a;
            v.search(a);

        }
        if(t == 4)
        {
            v.print();
        }
        m--;
    }
    //cout << count << endl;
    return 0;
}
```

## 2、什么是链表

#### 2.1	链表的定义

​	链表由一系列不必在内存中相连的结构构成。每一个结构均含有表元素和指向包含该元素后继元的结构的指针。我们称之为next指针。





![](D:\91193\Desktop\链表示意图.png)





#### 2.2	链表的基本操作

##### 2.2.1	链表的插入

​	插入操作实现函数insert，方法如下：

```latex
1. 找到链表中要插入的位置
2. 令待插入结点的next指针指向插入位置的当前结点。
3.令插入位置之前的当前结点的next指针指向待插入结点
```

##### 2.2.2	链表的遍历

```latex
1. 定义一个用于遍历的变量，初始指向头结点。
2. 输出遍历变量所在结点的值，并更新遍历变量为当前结点的下一个结点。
3.重复操作2，直到遍历完所有结点。
```

##### 2.2.3	链表的删除

```
1. 从表头遍历找到要删除的位置
2. 令删除位置的前一个结点的next指针指向待删除位置的后一个结点
3. 删除结点
```

##### 2.2.4	链表的反转

```latex
1. 定义一个用于遍历的指针，初始指向头结点的后一个结点
2. 令头结点的next置空
3. 从当前遍历指针所指的结点开始遍历链表，将遍历的结点next指针指向头结点，遍历过程借助另一个指针保存下一个遍历到的结点。
4. 重复步骤3直到链表尾
```

**输入格式**

第一行输入为一个正整数 m（1≤*m*≤100），代表一共有*m* 个操作。

接下来一共输入 *m* 行，每行首先输入一个整数 t，代表着以下几种操作：

- t = 1，代表执行插入操作，此时还需输入两个整数 a 和 b（0≤*a*,*b*≤100），代表在位置 a*a* 上插入值为 *b* 的元素，成功插入输出`success`，否则输出`failed`。
- t = 2，代表执行遍历操作，此时程序顺序输出链表的所有元素。
- t = 3，代表执行删除操作，此时还需输入一个整数 a（0≤*a*≤100），表示删除位置 a 上的元素，如果成功删除则输出`success`，否则输出`failed`。
- t = 4，代表执行反转链表的操作，在执行了反转操作之后，还会有其他的操作来验证你的程序是否正确的完成了链表的反转。

**输出格式**

输出的结果取决于每组输入的数据。在遍历输出链表时，每个元素后面跟一个空格。对于操作 1 和操作 3，操作成功输出`success`，否则输出`failed`。每次操作的输出各占一行。

**样例输入**

```
9
1 0 1
1 0 2
1 0 3
2
4
2
3 3
3 0
2
```

**样例输出**

```
success
success
success
3 2 1
1 2 3
failed
success
2 3
```



```c
#include <iostream>
#include<iostream>
using namespace std;

template <typename Type> class Node {
public:
    Type data;
    Node<Type> *next;
    Node(const Type &_data) {
        data = _data;
        next = NULL;
    }
};
template <typename Type> class LinkedList {
private:
    Node<Type> *head;
public:
    LinkedList() {
        head = NULL;
    }
    ~LinkedList() {
        Node<Type> *current_node = head;
        while (current_node != NULL) {
            Node<Type> *delete_node = current_node;
            current_node = current_node->next;
            delete delete_node;
        }
    }
    bool insert(Node<Type> *node, int index) {
        if (head == NULL) {
            if (index != 0) {
                return false;
            }
            head = node;
            return true;
        }
        if (index == 0) {
            node->next = head;
            head = node;
            return true;
        }
        Node<Type> *current_node = head;
        int count = 0;
        while (current_node->next != NULL && count < index - 1) {
            current_node = current_node->next;
            count++;
        }
        if (count == index - 1) {
            node->next = current_node->next;
            current_node->next = node;
            return true;
        }
        return false;
    }
    void output() {
        if (head == NULL) {
            return;
        }
        Node<Type> *current_node = head;
        while (current_node != NULL) {
            cout << current_node->data << " ";
            current_node = current_node->next;
        }
        cout << endl;
    }
    bool delete_node(int index) {
        if(head == NULL)
        {
            return false;
        }
        Node<Type> *current_node = head;
        int count = 0;
        if(index == 0)
        {
            head = head->next;
            delete current_node;
            return true;
        }
        while(current_node->next != NULL && count < index-1)
        {
            current_node = current_node->next;
            count++;
        }
        if(index-1 == count && current_node->next != NULL)
        {
            Node<Type> *delete_node = current_node->next;
            current_node->next = delete_node->next;
            delete delete_node;
            return true;
        }
        return false;
    }
    void reverse() {
        if(head == NULL)
        {
            return ;
        }
        Node<Type> *current_node = head->next;
        Node<Type> *next_node;
        head->next = NULL;
        while(current_node != NULL)
        {
            next_node = current_node->next;
            current_node->next = head;
            head = current_node;
            current_node = next_node;
        }
    }
};
int main() {
    LinkedList<int> linkedlist;
    int m, t, a, b;
    bool flag;
    cin >> m;
    while(m)
    {
        cin >> t;
        if(t == 1)
        {
            cin >> a >> b;
            Node<int> *node = new Node<int>(b);
            flag = linkedlist.insert(node, a);
            if(flag)
            {
                cout << "success" << endl;
            }
            else
            {
                cout << "failed" << endl;
            }
        }
        if(t == 2)
        {
            linkedlist.output();
        }
        if(t == 3)
        {
            cin >> a;
            flag = linkedlist.delete_node(a);
            if(flag)
            {
                cout << "success" << endl;
            }
            else
            {
                cout << "failed" << endl;
            }
        }
        if(t == 4)
        {
            linkedlist.reverse();
            //linkedlist.output();
        }
        m--;
    }
    return 0;
}
```





## 题目





![1600742321198](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1600742321198.png)





![1600746382033](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1600746382033.png)



![1601968957556](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1601968957556.png)





![1601971043597](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1601971043597.png)

![1602306451009](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602306451009.png)

![1602307288116](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602307288116.png)



![1602308841752](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602308841752.png)





![1602309276728](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602309276728.png)



![1602339230835](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602339230835.png)

![1602385655680](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602385655680.png)



![1602386219747](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602386219747.png)





![1602429462728](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602429462728.png)





![1602556095873](C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602556095873.png)



<img src="C:\Users\91193\AppData\Roaming\Typora\typora-user-images\1602669676916.png" alt="1602669676916" style="zoom:150%;" />





# C语言基础数据结构

## 单向链表

```c
/*************************************************************************
	> File Name: myList.c
	> Author:linshanglei 
	> Mail: 911930672@qq.com
	> Created Time: 2020年10月23日 星期五 05时46分29秒
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a, 32)

typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

typedef struct List {
    ListNode head;
    int length;
} List;

ListNode *getNewNode(int );
List *getLinkList();
void clear_node(ListNode *);
void clear(List*);
int insert(List *, int , int);
int erase(List *, int );
void output(List*);
void reverse(List *l);

int main() {
    srand(time(0));
    #define max_op 20
    List *l = getLinkList();
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        int index = rand() % (l->length + 3) - 1;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1: {
                printf("insert %d at %d to List = %d\n", val, index, insert(l, index, val));
            } break;
            case 2: {
                printf("erase item at %d from List = %d\n", index, erase(l, index));
            } break;
            case 3: {
                printf(GREEN("reverse the list !") "\n");
                reverse(l);
            } break;
        }
        output(l);
        printf("\n\n");
    }
    #undef max_op
    clear(l);
    return 0;
}

ListNode *getNewNode(int val) {
    ListNode *p = (ListNode*)malloc(sizeof(ListNode));
    p->data = val;
    p->next = NULL;
    return p;
}
List *getLinkList() {
    List *l = (List*)malloc(sizeof(List));
    l->head.next = NULL;
    l->length = 0;
    return l;
}

int insert(List *l, int index, int val) {
    if (l == NULL) return 0;
    if (index < 0 || index > l->length) return 0;
    ListNode *p = &(l->head), *node = getNewNode(val);
    while (index--) p = p->next;
    node->next = p->next;
    p->next = node;
    l->length++;
    return 1;

}

int erase(List *l, int index) {
    if (l == NULL)  return 0;
    if (index < 0 || index >= l->length) return 0;
    ListNode *p = &(l->head), *q;
    while (index--) p = p->next;
    q = p->next;
    p->next = q->next;
    l->length--;
    return 1;
}

void output(List *l) {
    if (l == NULL) return ;
    printf("List(%d) = [", l->length);
    for (ListNode *p = l->head.next; p; p = p->next) {
        printf("%d->", p->data);
    }
    printf("NULL]");
    return ;
}

void clear_node(ListNode *node) {
    if (node == NULL) return ;
    free(node);
    return ;
}

void clear(List *l) {
    if (l == NULL) return ;
    ListNode *p = l->head.next, *q;
    while (p) {
        q = p->next;
        clear_node(p);
        p = q;
    }
    free(l);
    return ;
}

void reverse(List *l) {
    ListNode *curr = l->head.next;
    l->head.next = NULL;
    while (curr != NULL) {
        ListNode *temp = curr->next;
        curr->next = l->head.next;
        l->head.next = curr;
        curr = temp;
    }
}
```

## 循环链表

```c++
/*************************************************************************
	> File Name: 循环链表.cpp
	> Author:linshanglei 
	> Mail: 911930672@qq.com
	> Created Time: 2020年11月05日 星期四 09时49分07秒
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define COLOR_HL(a, b) "\033[" #b "m" a "\033[0m"
#define RED_HL(a) COLOR_HL(a, 31)

typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

typedef struct List {
    ListNode head;
    int length;
} List;

ListNode *getNewNode (int value) {
    ListNode *p = (ListNode*)malloc(sizeof(ListNode));
    p->data = value;
    p->next = NULL;
    return p;
}

List *init_circle_list() {
    List *circle = (List*)malloc(sizeof(List));
    circle->head.next = &circle->head;
    circle->length = 0;
    return circle;
}

int insert(List *l, int index, int value) {
    if (l == NULL) return 0;
    if (index < 0 || index > l->length) return 0;
    ListNode *p = &(l->head), *node = getNewNode(value); //p要从虚拟头结点开始
    while (index--) p = p->next;
    node->next = p->next;
    p->next = node;
    l->length++;
    return 1;
}

int remove(List *l, int index) {
    if (l == NULL) return 0;
    if (index < 0 || index >= l->length) return 0;
    ListNode *p = &(l->head), *delete_node;
    while (index--) p = p->next;
    delete_node = p->next;
    p->next = delete_node->next;
    l->length--;
    return 1;
}

void output(List *l) {
    if (l == NULL) return ;
    printf("List(%d) = [", l->length);
    ListNode *curr = l->head.next;
    for (int i = 0; i < l->length; i++) {
        printf("%d->", curr->data);
        curr = curr->next;
    }
    printf("NULL]\n");
    return ;
}

void clear_node(ListNode *node) {
    if (node == NULL) return ;
    free(node);
    return ;
}

void clear(List *l) {
    if (l == NULL) return ;
    ListNode *p = l->head.next, *q;
    for (int i = 0; i < l->length; i++) {
        q = p->next;
        clear_node(p);
        p = q;
    }
    free(l);
    return ;
}

void test_print(List *l) {
    printf("test :");
    ListNode *p = l->head.next;
    for (int i = 0; i < l->length * 4; i++) {
        printf("%d->", p->data);
        p = p->next;
    }
    printf("NULL\n");
}

int main() {
    srand(time(0));
    #define max_op 20
    List *l = init_circle_list();
    List *l2 = init_circle_list();
    for (int i = 0; i < max_op; i++) {
        int value = rand() % 100;
        int index = rand() % (l->length + 3) - 1;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("insert %d at " RED_HL("%dth") "to List = %d\n", value, index, insert(l, index, value));
            } break;
            case 3: {
                printf("remove item at %dth from List = %d\n", index, remove(l, index));
            } break;
        }
        output(l);
        printf("\n");
    }
    printf("end\n");
    insert(l2, 0, 1);
    insert(l2, 1, 2);
    insert(l2, 2, 3);
    test_print(l2);
    clear(l2);
    #undef max_op
    clear(l);
    return 0;
}

```



## 双向循环链表

```c
/*************************************************************************
	> File Name: double_circular_linkedlist.c
	> Author:linshanglei 
	> Mail: 911930672@qq.com
	> Created Time: 2020年11月05日 星期四 13时45分05秒
 ************************************************************************/

#include <stdio.h>
#include <time.h>
#include <stdlib.h>

typedef struct ListNode {
    int data;
    struct ListNode *next, *pre;
} ListNode;

typedef struct List {
    ListNode head;
    int length;
} List;

ListNode *getNewNode(int value) {
    ListNode *p = (ListNode*)malloc(sizeof(ListNode));
    p->data = value;
    p->next = p->pre = NULL;
    return p;
}

List *init_double_circu_list() {
    List *l = (List*)malloc(sizeof(List));
    l->head.next = &l->head;
    l->head.pre = &l->head;
    l->length = 0;
    return l;
}

int insert(List *l, int index, int value) {
    if (l == NULL) return 0;
    if (index < 0 || index > l->length) return 0;
    ListNode *node = getNewNode(value);
    ListNode *curr = &l->head;
    while (index--) curr = curr->next;
    node->next = curr->next;
    curr->next->pre = node;
    curr->next = node;
    node->pre = curr;
    l->length++;
    return 1;
}

int remove(List *l, int index) {
    if (l == NULL) return 0;
    if (index < 0 || index >= l->length) return 0;
    ListNode *curr = l->head.next;
    while (index--) {
        curr = curr->next;
    }
    ListNode *delete_node = curr->next;
    curr->next = delete_node->next;
    delete_node->next->pre = curr;
    l->length--;
    return 1;
}

void clear_node(ListNode *node) {
    if (node == NULL) return ;
    free(node);
    return ;
}

void clear(List *l) {
    if (l == NULL) return ;
    ListNode *curr = l->head.next, *temp;
    for (int i = 0; i < l->length; i++) {
        temp = curr->next;
        clear_node(curr);
        curr = temp;
    }
    return ;
}

void output(List *l) {
    if (l == NULL) return ;
    ListNode *curr = l->head.next;
    printf("List(%d) = [", l->length);
    for (int i = 0; i < l->length; i++) {
        printf("%d->", curr->data);
        curr = curr->next;
    }
    printf("NULL]\n");
    return ;
}

void reversePrint(List *l) {
    if (l == NULL) return ;
    ListNode *curr = l->head.pre;
    printf("reversePrint List(%d) = [", l->length);
    for (int i = 0; i < l->length; i++) {
        printf("%d->", curr->data);
        curr = curr->pre;
    }
    printf("NULL]\n");
    return ;
}

void testPrint(List *l) {
    if (l == NULL) return ;
    ListNode *curr = l->head.next;
    printf("circylePrint List(%d) = [", l->length);
    for (int i = 0; i < l->length * 2 + 1; i++) {
        printf("%d->", curr->data);
        curr = curr->next;
    }
    printf("NULL]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    List *l = init_double_circu_list();
    for (int i = 0; i < max_op; i++) {
        int index = rand() % (l->length + 3) - 1;
        int value = rand() % 100;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("insert %d to the %dth in List = %d\n", value, index, insert(l, index, value));
            } break;
            case 3: {
                printf("remove %dth from List = %d\n", index, remove(l, index));
            } break;
        }
        output(l);
        reversePrint(l);
        printf("\n");
    }
    #undef max_op
    testPrint(l);
    clear(l);
    return 0;
}

```



## 队列

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define GREEN(a) COLOR(a, 32)

typedef struct Queue {
    int *data;
    int head, tail, length, cnt;
} Queue;

Queue *init(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->data = (int *)malloc(sizeof(int) * n);
    q->length = n;
    q->head = q->tail = q->cnt = 0;
    return q;
}

int front(Queue *q) {
    return q->data[q->head];
}

int empty(Queue *q) {
    return q->cnt == 0;
}

int expand(Queue *q) {
    int extr_size = q->length;
    int *p;
    while (extr_size) {
        p = (int *)malloc(sizeof(int) * (q->length + extr_size));
        if (p) break;
        extr_size >>= 1;
    }
    if (p == NULL) return 0;
    for (int i = q->head, j = 0; j < q->cnt; j++) {
        p[j] = q->data[(i + j) % q->length];
    }
    free(q->data);
    q->data = p;
    q->length += extr_size;
    q->head = 0;
    q->tail = q->cnt;
    return 1;
}

int push(Queue *q, int val) {
    if (q == NULL) return 0;
    if (q->cnt == q->length) {
        if (!expand(q)) return 0;
        printf(GREEN("expand successfully ! Queue->size(%d)") "\n", q->length);
    }
    q->data[q->tail++] = val;
    if (q->tail == q->length) q->tail = 0;
    q->cnt += 1;
    return 1;
}

int pop(Queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    q->head++;
    if (q->head == q->length) q->head = 0;
    q->cnt -= 1;
    return 1;
}

void output(Queue *q) {
    printf("Queue : [");
    for (int i = q->head, j = 0; j < q->cnt; i++, j++) {
        j && printf(", ");
        printf("%d", q->data[i % q->length]);
    }
    printf("]\n");
    return ;
}

void clear(Queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    Queue *q = init(max_op);
    for (int i = 0; i < max_op * 2; i++) {
        int val = rand() % 100;
        int op = rand() % 4;
        switch (op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to the Queue = %d\n", val, push(q, val));
            } break;
            case 3: {
                printf("pop %d from the Queue = %d\n", front(q), pop(q));
            } break;
        }
        output(q), printf("\n");
    }
    #undef max_op
    clear(q);
    return 0;
}

```



## 查找与排序

### 二分查找

```c++
#include <stdio.h>

#define P(func) {\
    printf("%s = %d\n", #func, func);\
}
//1 3 2 5 7 10
int binary_search1(int *nums, int n, int x) {
    int head = 0, tail = n - 1, mid;
    while (head <= tail) {
        mid = (head + tail) >> 1;
        if (nums[mid] == x) return mid;
        if (nums[mid] < x) head = mid + 1;
        else tail = mid - 1;
    }
    return -1;
}

//1 1 1 1 1 0 0 0 0 0
int binary_search2(int *nums, int n) {
    int head = -1, tail = n - 1, mid;
    while (head< tail) {
        mid = (head + tail + 1) >> 1;
        if (nums[mid] == 1) head = mid;
        else tail = mid - 1;
    }
    return head;
}

// 0 0 0 0 1 1 1 1 1
int binary_search3(int *nums, int n) {
    int head = 0, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (nums[mid] == 1) tail = mid;
        else head = mid + 1;
    }
    return head == n ? -1 : head;
}

int main() {
    int arr1[10] = {1, 3 , 5, 7, 9, 11, 13, 15, 17, 19};
    int arr2[10] = {1, 1, 1, 1, 1, 0, 0, 0, 0, 0};
    int arr3[10] = {0, 0, 0, 0, 0, 1, 1, 1, 1, 1};
    P(binary_search1(arr1, 10, 7));
    P(binary_search2(arr2, 10));
    P(binary_search3(arr3, 10));
    return 0;
}

```

### bsearch函数

```c
#include <stdio.h>
#include <stdlib.h>
 
 
int cmpfunc(const void * a, const void * b) {
   return ( *(int*)a - *(int*)b );
}
 
int values[] = { 5, 20, 26, 32, 63 };
 
int main () {
   int *item;
   int key = 32;
 
   /* 使用 bsearch() 在数组中查找值 32 */
   item = (int*) bsearch (&key, values, 5, sizeof (int), cmpfunc);
   if( item != NULL ) {
      printf("Found item = %d\n", *item);
   } else {
      printf("Item = %d could not be found\n", *item);
   }
   return 0;
}
```

### LeetCode 215、[数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```c++
class Solution {
public:
	int findKthLargest(vector<int> &nums, int k) {
        // 借助快排的过程
        return quickSort(nums, 0, nums.size() - 1, nums.size() - k);
    }

    int partition(vector<int> &nums, int left, int right){
        // 选取第一个元素为主元
        swap(nums[left], nums[(left + right) >> 1]);
        int pivot = nums[left];

        while(left < right){
            while(left < right && nums[right] >= pivot){
                right--;
            }
            nums[left] = nums[right];

            while(left < right && nums[left] <= pivot){
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        return left;
    }

    int quickSort(vector<int> &nums, int left, int right, int k){
        // 如果经过一轮快排分区后主元位置刚好是k，那么可以直接退出了
        int mid = partition(nums, left, right);
        if(mid == k){
            return nums[k];
        }else if(mid > k){
            return quickSort(nums, left, mid - 1, k);
        }else{
            return quickSort(nums, mid + 1, right, k);
        }
    }
};
```



### 稳定排序

​		所谓稳定排序即排序前后元素的相对位置不发生改变

#### 插入排序

​		将数组分为已排序区和待排序区，从后到前扫描已排序区，将待排序区的元素插到已排序区的正确位置，直至未排序区元素为0，时间复杂度O(n^2)

#### 冒泡排序

​		冒泡排序(BubbleSort)以其“在排序过程中相邻元素不断交换，一些元素慢慢被换到最后，看起来就像是元素在冒泡一样”而得名，是一种简单的基于关键词比较的排序算法。

​		**时间复杂度**

​		若文件的初始状态是排好序的的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数 M 均达到最小值（Cmin = n-1、Mmin = 0）所以，冒泡排序最好的时间复杂度为O(N)。


　　若初始文件是反序的，需要进行N趟排序。每趟排序要进行 C = N-1次关键字的比较(1≤i≤N-1)和总共(Mmax = (N*(N-1))/2)次的移动（移动次数由乱序对的个数决定，即多少对元素顺序不对，如 1 3 4 2 5 中共有(3,2)、(4,2)两个乱序对），在这种情况下，比较和移动次数均达到最大值（Cmax =N*(N-1) + Mmax=(N*(N-1))/2 = O(N^2)）。所以，冒泡排序的最坏时间复杂度为O(N^2)

 		综上，冒泡排序总的平均时间复杂度为O(N^2)。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    printf("Before ordering: ");\
    output(num, n);\
    printf("%s = ", #func);\
    func(args);\
    output(num, n);\
    printf("\n");\
    free(num);\
}

void insert_sort(int *num, int n) {
    for (int i = 1; i < n; i++) { //将第一个元素看作已排序区，则未排序间[1, n - 1]，扫描待排序区
        for (int j = i; j > 0 && num[j] < num[j - 1]; j--) {//从后往前扫描已排序区
            swap(num[j], num[j - 1]);
        }
    }
    return ;
}

void bubble_sort(int *num, int n) {
    for (int i = 0; i < n - 1; i++) {
        bool flag = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (num[j] <= num[j + 1]) continue;
            swap(num[j], num[j + 1]);
            flag = true;
        }
        if (!flag) break;
    }
    return ;
}

void merge_sort(int *num, int l, int r) {
    if (r - l <= 1) { //递归结束条件，当判断为真时，即此时待排序的元素只有两个
        if (r - l == 1 && num[r] < num[l]) { //若排在后面的元素比排在前面的小，即交换
            swap(num[l], num[r]); //交换后该趟排序已经完成，区间的元素是升序
        }
        return ;
    }
    int mid = (l + r) >> 1;
    merge_sort(num, l, mid); //分治左半边
    merge_sort(num, mid + 1, r); //分治右半边
    int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); //申请一片空间来保存该趟排序完成后的元素，大小为r - l + 1，因为此时r为元素索引下标，故需要加一
    int p1 = l, p2 = mid + 1, k = 0; //归并过程，p1和p2分别为要归并的两个序列的起始位置
    while (p1 <= mid || p2 <= r) { 
        //这里if的判断语句效果跟泽哥的一样，只是写法不同
        //每次循环我们都要找到一个元素插入到已排序区，假设左半边有元素要插入，有两种情况，1、右半边没有元素要插入了 2、左半边的待插入元素比右半边的小
        if (p1 <= mid && (p2 > r || num[p1] <= num[p2])) {
            temp[k++] = num[p1++];
        } else {
            temp[k++] = num[p2++];
        }
    }
    memcpy(num + l, temp, sizeof(int) * (r - l + 1));//当代码进行到这一行时，此时temp的[l, r]已经被排好序了，所以我们要把原数组的[l, r]部分更新为temp的[l, r]
    free(temp); //释放申请的空间
    return ;
}

void randint(int *num, int n) {
    while (n--) num[n] = rand() % 100;
    return ;
}

void output(int *num, int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf(" %d", num[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int arr[max_op];
    randint(arr, max_op);
    TEST(arr, max_op, insert_sort, num, max_op);
    TEST(arr, max_op, bubble_sort, num, max_op);
    TEST(arr, max_op, merge_sort, num, 0, max_op - 1);
    return 0;
}

```



### 不稳定排序

#### 选择排序

​		对于选择排序，首先理解排序的思想。给定一个数组，这种思想首先假定数组的首元素为最大或者最小的。

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>

#define swap(a, b) {\
    __typeof(a) temp = a;\
    a = b; b = temp;\
}

#define TEST(arr, n, func, args...) {\
    int *nums = (int*)malloc(sizeof(int) * n);\
    memcpy(nums, arr, sizeof(int) * n);\
    output(nums, n);\
    printf("%s = ", #func);\
    func(args);\
    output(nums, n);\
    free(nums);\
    printf("\n");\
}

void output(int *nums, int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        i && printf(" ");
        printf("%d", nums[i]);
    }
    printf("]\n");
}
void select_sort(int *nums, int n) {
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++) {
            if (nums[min] > nums[j]) {
                min = j;
            }
        }
        if (min != i) swap(nums[i], nums[min]);
    }
}

void quick_sort(int *nums, int left, int right) {
    if (left > right) return ;
    int x = left, y = right, pivot = nums[x];
    while (x < y) {
        while (x < y && nums[y] > pivot) --y;
        if (x < y) nums[x++] = nums[y];
        while (x < y && nums[x] < pivot) ++x;
        if (x < y) nums[y--] = nums[x];
    }
    nums[x] = pivot;
    quick_sort(nums, left, x - 1);
    quick_sort(nums, x + 1, right);
    return ;
}

void randint(int *nums, int n) {
    while(n--) nums[n] = rand() % 100;
    return ;
}

int main() {
    srand(time(0));
    #define max_op 7
    int arr[max_op];
    randint(arr, max_op);
    TEST(arr, max_op, select_sort, nums, max_op);
    TEST(arr, max_op, quick_sort, nums, 0, max_op - 1);
    #undef max_op
    return 0;
}

```

#### 快速排序

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

#define max_n 10000

#define swap(a, b) {\
    __typeof(a) temp = a;\
    a = b, b = temp;\
}

void quick_sort(int *nums, int l, int r) {
    while (l < r) {
        int x = l, y = r, z = nums[(l + r) >> 1];
        do {
            while (x <= y && nums[x] < z) x++;
            while (x <= y && nums[y] > z) y--;
            printf("x = %d y = %d\n", x, y);
            if (x <= y) {
                swap(nums[x], nums[y]);
                x++, y--;
            }
        } while (x <= y);
        quick_sort(nums, x, r); //当执行到这一步时，x ～ r区间为比基准值大的数
        r = y; // 用r来保存比基准直小的区间的右边界
    }
    return ;
}

int arr[max_n + 5];

void randiint(int *nums, int n) {
    for (int i = 0; i < n; i++) nums[i] = n - i;
    return ;
}

void output(int *nums, int n) {
    printf("arr = [");
    for (int i = 0; i < n; i++) {
        printf(" %d", nums[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    randiint(arr, max_n);
    output(arr, max_n);
    quick_sort(arr, 0, max_n - 1);
    output(arr, max_n);
    return 0;
}
```



#### 堆排序

[堆排序详解](https://www.cnblogs.com/chengxiao/p/6129630.html)

堆排序的思路：

​	首先将无序序列构建成一个大根堆，则堆顶元素为最大值，再将末尾元素与堆顶元素交换，此时末尾元素即为最大值，之后再将剩下的n - 1个元素建大根堆，再交换末尾与堆顶元素，反复执行即可得到有序数列

第一个非叶子结点即是最后一个叶子结点的父节点，假设二叉树的结点数为n，则其索引为[0, n - 1]；那么最后一个节点的索引是n - 1；则其父亲结点的索引为((n - 1) - 1) / 2；即为 n / 2 - 1.

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

void output(int *arr, int n);
//使得最大值在arr[1]位置
void downUpdate(int *arr, int n, int index) {
    while ((index << 1) <= n) {
        int temp = index, l = index << 1, r = index << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == index) break;
        swap(arr[temp], arr[index]);
        index = temp;
    }
}

void heap_sort(int *arr, int n) {
    //使得无序序列中的最大值在堆顶
    for (int i = n >> 1 - 1; i >= 0; i--) {
        downUpdate(arr, n, i);
    }
    依次将剩下的n - 1个元素建堆并交换
    for (int i = n - 1; i > 0; i--) {
        swap(arr[i], arr[0]);
        downUpdate(arr, i, 0);
    }
    return ;
}

void output(int *arr, int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf(" %d", arr[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_n 6
    int *arr = (int *)malloc(sizeof(int) * max_n);
    for (int i = 0; i < max_n; i++) {
        arr[i] = rand() % 100;
    }
    output(arr, max_n);
    heap_sort(arr, max_n);
    output(arr, max_n);
    free(arr);
    return 0;
}

```



```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

void downUpdate(int *arr, int n, int index) {
    while ((index << 1) <= n) {
        int temp = index, l = index << 1, r = index << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == index) break;
        swap(arr[temp], arr[index]);
        index = temp;
    }
}

void heap_sort(int *arr, int n) {
    arr -= 1;
    for (int i = n >> 1; i >= 1; i--) {
        downUpdate(arr, n, i);
    }
    for (int i = n; i > 1; i--) {
        swap(arr[i], arr[1]);
        downUpdate(arr, i - 1, 1);
    }
    return ;
}

void output(int *arr, int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf(" %d", arr[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_n 20
    int *arr = (int *)malloc(sizeof(int) * max_n);
    for (int i = 0; i < max_n; i++) {
        arr[i] = rand() % 100;
    }
    output(arr, max_n);
    heap_sort(arr, max_n);
    output(arr, max_n);
    free(arr);
    return 0;
}

```





## 二叉树

### 二叉搜索树

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
    
#define max_op 20

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
} Node;

typedef struct Tree {
    Node *root;
    int n;
} Tree;

Node *init_node(int val) {
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = val;
    p->lchild = p->rchild = NULL;
    return p;
}

Tree *init_tree() {
    Tree *tree = (Tree*)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}

void clear_node(Node *node) {
    if (!node) return ;
    clear_node(node->lchild);
    clear_node(node->rchild);
    free(node);
    return ;
}

void clear_tree(Tree *tree) {
    if (!tree) return ;
    clear_node(tree->root);
    free(tree);
    return ;
}

Node *insert_node(Node *root, int val, int *flag) {
    if (!root) return init_node(val);
    if (val == root->data) {
        *flag = 1;
        return root;
    }
    if (val < root->data) root->lchild = insert_node(root->lchild, val, flag);
    else root->rchild = insert_node(root->rchild, val, flag);
    return root;
}

void insert(Tree *tree, int val) {
    int flag = 0;
    tree->root = insert_node(tree->root, val, &flag);
    tree->n += flag;
    return ;
}

void pre_order_node(Node *node) {
    if (!node) return ;
    printf("%d ", node->data);
    pre_order_node(node->lchild);
    pre_order_node(node->rchild);
    return ;
}

void pre_order(Tree *tree) {
    if (!tree) return ;
    printf("pre_order : ");
    pre_order_node(tree->root);
    printf("\n");
}

void in_order_node(Node *node) {
    if (!node) return ;
    in_order_node(node->lchild);
    printf("%d ", node->data);
    in_order_node(node->rchild);
    return ;
}

void in_order(Tree *tree) {
    if (!tree) return ;
    printf("pre_order : ");
    in_order_node(tree->root);
    printf("\n");
}

void post_order_node(Node *node) {
    if (!node) return ;
    post_order_node(node->lchild);
    post_order_node(node->rchild);
    printf("%d ", node->data);
    return ;
}

void post_order(Tree *tree) {
    if (!tree) return ;
    printf("pre_order : ");
    post_order_node(tree->root);
    printf("\n");
}

void output_node(Node *node) {
    if (!node) return ;
    printf("%d", node->data);
    if (!node->lchild && !node->rchild) return ;
    printf("(");
    output_node(node->lchild);
    printf(", ");
    output_node(node->rchild);
    printf(")");
    return ;
}
void output(Tree *tree) {
    if (!tree) return ;
    printf("tree(%d) : ", tree->n);
    output_node(tree->root);
    printf("\n");
    return ;
}
int main() {
    srand(time(0));
    Tree *tree = init_tree();
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        insert(tree, val);
        output(tree);
    }
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    clear_tree(tree);
    return 0;
}

```



### 广义表建立二叉树

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Node {
    char data;
    struct Node *lchild, *rchild;
} Node;

typedef struct Tree {
    Node *root;
    int n;
} Tree;

typedef struct Stack {
    Node **data;
    int top, size;
} Stack;

Node *init_node(char data) {
    Node *p = (Node*)malloc(sizeof(Node));
    p->lchild = p->rchild = NULL;
    p->data = data;
    return p;
}

void clear_node(Node *node) {
    if (!node) return ;
    free(node->lchild);
    free(node->rchild);
    free(node);
    return ;
}

Tree *init_tree() {
    Tree *tree = (Tree*)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}

void clear_tree(Tree *tree) {
    if (!tree) return ;
    clear_node(tree->root);
    free(tree);
    return ;
}

Stack *init_stack(int n) {
    Stack *s = (Stack*)malloc(sizeof(Stack));
    s->size = n;
    s->top = -1;
    s->data = (Node**)malloc(sizeof(Node*) * n);
    return s;
}

void clear_stack(Stack *s) {
    if (s == NULL) return ;
    free(s->data);
    free(s);
    return ;
}

bool empty(Stack *s) {
    return s->top == -1;
}

int push(Stack *s, Node *node) {
    if (s->top == s->size - 1) return 0;
    if (!s) return 0;
    s->data[++(s->top)] = node;
    return 1;
}

Node *top(Stack *s) {
    if (!s || empty(s)) return 0;
    return s->data[s->top];
}

int pop(Stack *s) {
    if (empty(s)) return 0;
    if (!s) return 0;
    s->top--;
    return 1;
}

Node* build(const char *str, int *node_num) {
    Stack *s = init_stack(sizeof(str));
    Node *temp, *ans;
    temp = ans = NULL;
    int flag = 0;
    while (str[0]) {
        switch (str[0]) {
            case '(':
                flag = 1;
                push(s, temp);
                break;
            case ',':
                flag = 2;
                break;
            case ')':
                ans = top(s);
                flag = 3;
                pop(s);
                break;
            case ' ':
                break;
            default :
                temp = init_node(str[0]);
            if (!empty(s) && flag == 1) {
                top(s)->lchild = temp;
            } else if (!empty(s) && flag == 2) {
                top(s)->rchild = temp;
            }
            ++(*node_num);
            break;
        }
        ++str;
    }
    if (!ans && temp) ans = temp;
    clear_stack(s);
    return ans;
}

void pre_order_node(Node *node) {
    if (!node) return ;
    printf("%c ", node->data);
    pre_order_node(node->lchild);
    pre_order_node(node->rchild);
    return ;
}

void pre_order(Tree *tree) {
    if (!tree) return ;
    printf("pre_order : ");
    pre_order_node(tree->root);
    printf("\n");
    return ;
}

void in_order_node(Node *node) {
    if (!node) return ;
    in_order_node(node->lchild);
    printf("%c ", node->data);
    in_order_node(node->rchild);
    return ;
}

void in_order(Tree *tree) {
    if (!tree) return ;
    printf("in_order : ");
    in_order_node(tree->root);
    printf("\n");
    return ;
}

void post_order_node(Node *node) {
    if (!node) return ;
    post_order_node(node->lchild);
    post_order_node(node->rchild);
    printf("%c ", node->data);
    return ;
}

void post_order(Tree *tree) {
    if (!tree) return ;
    printf("post_order : ");
    post_order_node(tree->root);
    printf("\n");
    return ;
}
int main() {
    srand(time(0));
    char str[500] = {0};
    scanf("%[^\n]", str);
    Tree *tree = init_tree();
    tree->root = build(str, &tree->n);
    pre_order(tree);
    in_order(tree);
    post_order(tree);
    clear_tree(tree);
    return 0;
}

```



## 优先队列

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct priority_queue {
    int *data;
    int cnt, size; //size代表队列容量，cnt代表当前队列的数量
} priority_queue;

priority_queue *init(int n) {
    priority_queue *q = (priority_queue*)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * (n + 1));
    q->cnt = 0;
    q->size = n;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

int top(priority_queue *q) {
    return q->data[1];
}

int push(priority_queue *q, int value) {
    if (q == NULL) return 0;
    if (q->cnt == q->size) return 0;
    q->data[++(q->cnt)] = value;
    int index = q->cnt;
    while (index >> 1 && q->data[index] > q->data[index >> 1]) {
        swap(q->data[index], q->data[index >> 1]);
        index >>= 1;
    }
    return 1;
}

int pop(priority_queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    q->data[1] = q->data[q->cnt--];
    int index = 1;
    while ((index << 1) <= q->cnt) {
        int temp = index, l = index << 1, r = index << 1 | 1;
        if (q->data[l] > q->data[temp]) temp = l;
        if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;
        if (temp == index) break;
        swap(q->data[temp], q->data[index]);
        index = temp;
    }
    return 1;
}


void clear(priority_queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 10
    priority_queue *q = init(max_op);
    for (int  i = 0; i < max_op; i++) {
        int value = rand() % 100;
        push(q, value);
        printf("insert %d to the priority_queue\n", value);
    }
    for (int i = 0; i < max_op; i++) {
        printf("%d ", top(q));
        pop(q);
    }
    printf("\n");
    clear(q);
    #undef max_op
    return 0;
}

```



## 哈希表

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char *str;
    struct Node *next;
} Node;

typedef struct HashTable {
    Node **data;
    int size;
} HashTable;

Node *init_node(char *str, Node *head) {
    Node *p = (Node*)malloc(sizeof(Node));
    p->str = strdup(str);
    p->next = head;
    return p;
}
HashTable *init_hashtable(int n) {
    HashTable *h = (HashTable*)malloc(sizeof(HashTable));
    h->size = n << 1;
    h->data = (Node**)calloc(h->size, sizeof(Node*));
    return h;
}

void clear_node(Node *node) {
    if (node == NULL) return ;
    Node *p = node, *q;
    while (p) {
        q = p->next;
        free(p->str);
        free(p);
        p = q;
    }
    free(q);
    return ;
}

void clear_hash_table(HashTable *h) {
    if (h == NULL) return ;
    for (int i = 0; i < h->size; i++) {
        clear_node(h->data[i]);
    }
    free(h->data);
    free(h);
    return ;
}

int BKDRHash(char *str) {
    int seed = 31, hash = 0;
    for (int i = 0; str[i]; i++) hash = hash * seed + str[i];
    return hash & 0x7fffffff;
}

int insert(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int index = hash % h->size;
    h->data[index] = init_node(str, h->data[index]);
    return 1;
}

int search(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int index = hash % h->size;
    Node *p = h->data[index];
    while (p && strcmp(p->str, str)) {
        p = p->next;
    }
    return p != NULL;
}


int main() {
    int op;
    #define max_op 100
    char str[max_op + 5] = {0};
    HashTable *h = init_hashtable(max_op + 5);
    while (~scanf("%d%s", &op, str)) {
        switch (op) {
            case 0:
                printf("insert %s to the hash table\n", str);
                insert(h, str);
                break;
            case 1:printf("search %s from HashTable result = %d\n", str, search(h, str));
            break;
        }
    }
    #undef max_op
    clear_hash_table(h);
    return 0;
}

```



### 森林与并查集

​		解决连通性问题

[森林与并查集](https://blog.csdn.net/weixin_43899266/article/details/104447958?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160498013319724838548302%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160498013319724838548302&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-104447958.pc_search_result_cache&utm_term=%E6%A3%AE%E6%9E%97%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86&spm=1018.2118.3001.4449)

Quick_find算法

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct UnionSet {
    int *color;
    int n; //当前并查集大小
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet*)malloc(sizeof(UnionSet));
    u->color = (int*)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->color[i] = i;
    }
    return u;
} 

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->color);
    free(u);
    return ;
}

int find(UnionSet *u, int x) {
    return u->color[x];
}

int merge(UnionSet *u, int a, int b) {
    if (find(u, a) == find(u, b)) return 0;
    int color_a = u->color[a];
    for (int i = 0; i <= u->n; i++) {
        if (u->color[i] - color_a) continue;
        u->color[i] = u->color[b];
    }
    return 1;
}

int main() {
    int n, m;
    int a, b, c;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");
                    break;
        }
    }
    clear(u);
    return 0;
}

```



按秩合并

```c
#include <stdio.h>
#include <stdlib.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father, *size;
    int n; //当前并查集大小
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet*)malloc(sizeof(UnionSet));
    u->father = (int*)malloc(sizeof(int) * (n + 1));
    u->size = (int*)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->father[i] = i;
        u->size[i] = 1;
    }
    return u;
} 

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->father);
    free(u->size);
    free(u);
    return ;
}

int find(UnionSet *u, int x) {
    if (u->father[x] == x) return x;
    return find(u, u->father[x]);
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    if (u->size[fa] < u->size[fb]) swap(fa, fb);//保证father_a记录的是结点数量最多的
    u->father[fb] = fa;
    u->size[fa] += u->size[fb];
    return 1;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");
                    break;
        }
    }
    clear(u);
    return 0;
}

```



路径压缩

```c
#include <stdio.h>
#include <stdlib.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father;
    int n; //当前并查集大小
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet*)malloc(sizeof(UnionSet));
    u->father = (int*)malloc(sizeof(int) * (n + 1));
    //u->size = (int*)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->father[i] = i;
        //u->size[i] = 1;
    }
    return u;
} 

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->father);
    //free(u->size);
    free(u);
    return ;
}

int find(UnionSet *u, int x) {
    return u->father[x] = (u->father[x] == x ? x : find(u, u->father[x]));
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    //if (u->size[fa] < u->size[fb]) swap(fa, fb);//保证father_a记录的是结点数量最多的
    u->father[fb] = fa;
    //u->size[fa] += u->size[fb];
    return 1;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");
                    break;
        }
    }
    clear(u);
    return 0;
}

```



## 哈夫曼树

[哈夫曼树详解](https://blog.csdn.net/wardseptember/article/details/80717653?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160498093719724836734491%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160498093719724836734491&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-3-80717653.pc_search_result_cache&utm_term=%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91&spm=1018.2118.3001.4449)



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define max_n 1000

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}
typedef struct Node {
    char ch;
    double p;
    struct Node *next[2];//next[0]左孩子
} Node;

//将字符及其出现的概率封装成一个结构体
typedef struct Data {
    char ch;
    double p;//当前字符出现概率
} Data;

//记录哈夫曼树每个字符的编码
typedef struct Code {
    char ch;
    char *str;
} Code;

typedef struct Haffman_Tree {
    Node *root;
    int n;
    Code *codes;
} Haffman_Tree;

Data arr[max_n + 5];

Node *getNewNode(Data *obj) {
    Node *p = (Node*)malloc(sizeof(Node));
    p->ch = (obj ? obj->ch : 0);
    p->p = (obj ? obj->p : 0);
    p->next[0] = p->next[1] = NULL;
    return p;
}

Haffman_Tree *getNewTree(int n) {
    Haffman_Tree *tree = (Haffman_Tree*)malloc(sizeof(Haffman_Tree));
    tree->n = n;
    tree->codes = (Code*)malloc(sizeof(Code) * n);
    tree->root = NULL;
    return tree;
}

void insertOnce(Node **arr, int n) {
    for (int j = n; j >= 1; j--) {
        if (arr[j]->p > arr[j - 1]->p) {
            swap(arr[j], arr[j - 1]);
            continue;
        }
        break;
    }
    return ;
}

int extreact_Codes(Node *root, Code *arr, int k, int l, char *buffer) { //l为哈夫曼树层数
    buffer[l] = 0;
    if (root->next[0] == NULL && root->next[1] == NULL) {
        arr[k].ch = root->ch;
        arr[k].str = strdup(buffer);
        return 1;111
    } 
    int delta = 0;
    buffer[l] = '0';
    delta += extreact_Codes(root->next[0], arr, k + delta, l + 1, buffer); //往左子树递归
    buffer[l] = '1';
    delta += extreact_Codes(root->next[1], arr, k + delta, l + 1, buffer);
    return delta;
}

Haffman_Tree *build(Data *arr, int n) {
    Node **nodes = (Node**)malloc(sizeof(Node*) * n);
    for (int i = 0; i < n; i++) {
        nodes[i] = getNewNode(arr + i);
    }
    //利用插入排序将各字符按出现概率的大小作降序排序
    for (int i = 1; i < n; i++) {
        insertOnce(nodes, i);
    }
    //将出现概率大小进行合并
    for (int i = n - 1; i >= 1; i--) {
        Node *p = getNewNode(NULL);
        p->next[0] = nodes[i - 1];
        p->next[1] = nodes[i];
        p->p = nodes[i - 1]->p + nodes[i - 1]->p;
        nodes[i - 1] = p;
        insertOnce(nodes, i - 1);
    }
    char *buffer = (char*)malloc(sizeof(char) * n);
    Haffman_Tree *tree = getNewTree(n);
    tree->root = nodes[0];
    //if (nodes[0]->next[0] != NULL) printf("yes\n");
    extreact_Codes(tree->root, tree->codes, 0, 0, buffer);
    free(nodes);
    free(buffer);
    return tree;
}

int main() {
    int n;
    char str[10];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s%lf", str, &arr[i].p);
        arr[i].ch = str[0];
    }
    Haffman_Tree *tree = build(arr, n);
    for (int i = 0; i < tree->n; i++) {
        printf("%c : %s\n", tree->codes[i].ch, tree->codes[i].str);

    }
    return 0;
}

```

